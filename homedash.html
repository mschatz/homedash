<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HomeDash</title>
  <link rel="icon" type="image/svg+xml" href="favicon.svg" />
  <style>
    :root{
      --bg: #000000;
      --fg: #ff4444;
      --date: #ff4444;
      --font: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;

      /* Software dimmer: higher = darker overall (0.0 to 0.8 is practical) */
      --dim: 0.0;

      /* Clock size: adjust to taste for 5" display */
      --clockSize: 48px;
      --dateSize: 14px;
      --calCellSizeWidth: 40px;
      --calCellSizeHeight: 32px;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      overflow: hidden;
    }

    /* Main container */
    #wrap {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      font-family: var(--font);
      user-select: none;
      padding: 0;
    }

    /* Top composite section */
    #topSection {
      display: flex;
      gap: 2px;
      flex: 1.25;
      min-height: 0;
      min-width: 0;
      padding: 2px 2px 1px;
    }

    #rightTop {
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 2px;
      flex: 1 1 0;
      min-width: 0;
      min-height: 0;
      border: 1px solid rgba(192, 25, 25, 0.2);
      border-radius: 8px;
      padding: 8px;
    }

    /* Clock section in top-right */
    #clockSection {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      flex: 0 0 auto;
      border: 0;
      border-radius: 0;
      padding: 0;
    }

    /* Clock block */
    #clockBlock {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      text-align: center;
      letter-spacing: 0.02em;
    }

    #time {
      font-size: 72px;
      color: var(--fg);
      font-weight: 600;
      line-height: 1;
      text-shadow: 0 0 10px rgba(122, 27, 27, 0.08); /* subtle glow */
      white-space: nowrap;
    }

    #date {
      font-size: 30px;
      color: #d4af37;
      font-weight: 500;
      opacity: 0.95;
      line-height: 1.2;
      text-align: center;
      margin: 0 10px;
      cursor: pointer;
    }

    /* Calendar (top-right, below time) */
    #calendar {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      flex: 0 0 auto;
      min-width: 0;
      min-height: 0;
      padding: 2px 8px 0;
      border: 0;
      border-radius: 0;
      width: 100%;
    }

    #calNav {
      display: flex;
      align-items: center;
      gap: 8px;
      justify-content: center;
      width: 100%;
      padding-bottom: 4px;
      border-bottom: 1px solid #c01919;
      margin-bottom: 10px;
    }

    #calNav button {
      background: transparent;
      border: 1px solid var(--fg);
      color: var(--fg);
      font-family: var(--font);
      font-size: 10px;
      padding: 1px 4px;
      border-radius: 3px;
      cursor: pointer;
      opacity: 0.8;
      transition: opacity 0.2s;
      line-height: 1;
    }

    #calNav button:hover {
      opacity: 1;
    }

    #calGrid {
      display: grid;
      width: 100%;
      grid-template-columns: repeat(7, minmax(0, 1fr));
      gap: 0px;
      margin-top: 2px;
    }

    .calHeader {
      font-size: clamp(13px, 2.4vw, 16px);
      color: var(--date);
      text-align: center;
      padding: 0px 0;
      font-weight: 600;
      opacity: 0.7;
      line-height: 1;
    }

    .calDay {
      width: 100%;
      height: clamp(20px, 4.6vh, 32px);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(15px, 3.3vw, 23px);
      color: var(--date);
      border-radius: 3px;
      line-height: 1;
    }

    .calDay.otherMonth {
      opacity: 0.5;
    }

    .calDay.today {
      background: #d4af37;
      color: #000;
      font-weight: 700;
    }

    /* Left panel: current weather */
    #currentWeather {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      flex: 0 0 33%;
      min-width: 220px;
      border: 1px solid rgba(192, 25, 25, 0.3);
      border-radius: 8px;
      padding: 16px;
      gap: 12px;
      font-family: Arial, Helvetica, sans-serif;
      position: relative;
    }

    #weatherClock {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: calc(100% - 20px);
      height: auto;
      aspect-ratio: 1 / 1;
      max-height: calc(100% - 20px);
      pointer-events: none;
      opacity: 0.85;
    }

    #currentWeatherContent {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: calc(100% - 20px);
      height: auto;
      aspect-ratio: 1 / 1;
      max-height: calc(100% - 20px);
      z-index: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    #weatherIcon {
      font-size: clamp(52px, 9.5vw, 88px);
      line-height: 1;
    }

    #currentTemp {
      font-size: clamp(32px, 7vw, 56px);
      color: #ff4444;
      font-weight: 600;
    }

    #currentPrecipSummary {
      font-size: clamp(13px, 2.6vw, 18px);
      color: #b0b0b0;
      text-align: center;
      margin-top: -3px;
    }

    #weatherLocation {
      font-size: clamp(11px, 2.2vw, 16px);
      color: rgba(227, 17, 17, 0.755);
      text-align: center;
      font-weight: 700;
    }

    @media (max-width: 700px) {
      #topSection {
        flex-direction: column;
      }

      #rightTop {
        width: 100%;
      }

      #calendar,
      #currentWeather {
        width: 100%;
        min-width: 0;
      }
    }

    /* Bottom section: line chart */
    #chartSection {
      display: flex;
      flex-direction: column;
      flex: 1.1;
      min-height: 0;
      gap: 1px;
      padding: 0 2px 10px;
      border-top: 1px solid rgba(192, 25, 25, 0.2);
    }

    #chartContainer {
      flex: 1;
      min-height: 0;
      position: relative;
    }

    #chart {
      width: 100%;
      height: 100%;
    }

    #chartLegend {
      display: flex;
      justify-content: center;
      gap: 20px;
      font-size: 11px;
      flex-shrink: 0;
    }

    .legendItem {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .legendBox {
      width: 12px;
      height: 12px;
      border-radius: 2px;
    }

    /* Chart hover tooltip */
    #chartTooltip {
      position: fixed;
      z-index: 5;
      background: rgba(0, 0, 0, 0.85);
      color: #e6e6e6;
      border: 1px solid rgba(192, 25, 25, 0.5);
      border-radius: 6px;
      padding: 6px 8px;
      font-size: 12px;
      font-family: var(--font);
      pointer-events: none;
      display: none;
      white-space: nowrap;
    }

    /* Software dim overlay */
    #dim {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,var(--dim));
      pointer-events: none;
    }

    /* Help overlay (hidden by default; toggle with ?) */
    #help {
      position: fixed;
      left: 18px;
      bottom: 14px;
      font-family: var(--font);
      font-size: 12px;
      color: rgba(255,255,255,0.30);
      background: rgba(0,0,0,0.35);
      padding: 8px 10px;
      border-radius: 8px;
      display: none;
      line-height: 1.35;
      max-width: 400px;
    }

    #help kbd{
      font-family: var(--font);
      background: rgba(255,255,255,0.08);
      padding: 1px 5px;
      border-radius: 4px;
      margin: 0 2px;
    }
  </style>
</head>
<body>
  <div id="wrap">
    <div id="topSection">
      <div id="currentWeather">
        <svg id="weatherClock" viewBox="0 0 100 100" aria-hidden="true"></svg>
        <div id="currentWeatherContent">
          <div id="weatherIcon">‚òÄÔ∏è</div>
          <div id="currentTemp">68¬∞F</div>
          <div id="currentPrecipSummary">--% | --in</div>
          <div id="weatherLocation">Loading...</div>
        </div>
      </div>

      <div id="rightTop">
        <div id="clockSection">
          <div id="clockBlock" aria-label="clock">
            <div id="time">--:--:--</div>
          </div>
        </div>

        <div id="calendar">
          <div id="calNav">
            <button id="prevMonth">‚óÄ</button>
            <div id="date" title="Go to current month"></div>
            <button id="nextMonth">‚ñ∂</button>
          </div>
          <div id="calGrid"></div>
        </div>
      </div>
    </div>

    <!-- Bottom section: line chart (~2") -->
    <div id="chartSection">
      <div id="chartContainer">
        <canvas id="chart"></canvas>
      </div>
      <div id="chartLegend">
        <div class="legendItem">
          <div class="legendBox" style="background: var(--temp-color);"></div>
          <span>Temperature (¬∞F) ‚Äî Left Axis</span>
        </div>
        <div class="legendItem">
          <div class="legendBox" style="background: var(--precip-color);"></div>
          <span>Precipitation (%) ‚Äî Right Axis</span>
        </div>
      </div>
    </div>
  </div>
  <div id="dim"></div>
  <div id="chartTooltip"></div>

  <div id="help">
    <div><strong>HomeDash</strong> shortcuts:</div>
    <div>
      <kbd>+</kbd>/<kbd>-</kbd> dimmer &nbsp; ‚Ä¢ &nbsp;
      <kbd>?</kbd> help &nbsp; ‚Ä¢ &nbsp;
      <kbd>t</kbd> 24h
    </div>
    <div style="margin-top:4px;">
      Tip: Full-screen: <kbd>Ctrl</kbd>+<kbd>‚åò</kbd>+<kbd>F</kbd>
    </div>
  </div>

  <script>
    // ---------- Settings ----------
    const UPDATE_EVERY_SEC = 1;
    const WEATHER_CACHE_MS = 60 * 60 * 1000;
    const GEO_CACHE_MS = 60 * 60 * 1000;
    const WEATHER_CACHE_VERSION = 2;
    const MIN_HOURLY_POINTS = 192;
    const USE_24H_DEFAULT = false;

    // ---------- State ----------
    let use24h = USE_24H_DEFAULT;
    let dim = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--dim')) || 0;
    let viewYear, viewMonth;
    let chartHoverIndex = null;
    let weatherData = {
      current: { temp: '--', description: 'Loading...', icon: '‚òÄÔ∏è' },
      hourly: [],
      dailyPeriods: []
    };

    const timeEl = document.getElementById('time');
    const dateEl = document.getElementById('date');
    const help = document.getElementById('help');
    const calGrid = document.getElementById('calGrid');
    const weatherIcon = document.getElementById('weatherIcon');
    const currentTemp = document.getElementById('currentTemp');
    const currentPrecipSummary = document.getElementById('currentPrecipSummary');
    const weatherLocation = document.getElementById('weatherLocation');
    const weatherClock = document.getElementById('weatherClock');
    const currentWeather = document.getElementById('currentWeather');
    const chartCanvas = document.getElementById('chart');
    const chartTooltip = document.getElementById('chartTooltip');

    function pad(n){ return String(n).padStart(2,'0'); }
    function hourKeyFromDate(d){
      return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}T${pad(d.getHours())}`;
    }
    function formatInches(v){
      if (v === null || v === undefined || Number.isNaN(v)) return '‚Äî';
      if (v < 0.05) return '0';
      const rounded = Math.round(v * 10) / 10;
      return rounded.toFixed(1).replace(/\.0$/, '');
    }
    function formatTimeShort(d){
      if (!d || Number.isNaN(d.getTime())) return '--';
      return d.toLocaleTimeString(undefined, { hour: 'numeric', minute: '2-digit' });
    }
    function roundCoord(value, precision = 2){
      const factor = Math.pow(10, precision);
      return Math.round(value * factor) / factor;
    }
    function getWeatherCacheKey(lat, lon){
      return `weatherCache_v${WEATHER_CACHE_VERSION}_${roundCoord(lat)}_${roundCoord(lon)}`;
    }
    function getGeoCacheKey(){
      return 'geoCache';
    }
    function reviveWeatherData(raw){
      if (!raw || !raw.hourly) return null;
      const current = raw.current || {};
      return {
        current: {
          ...current,
          sunrise: current.sunrise ? new Date(current.sunrise) : null,
          sunset: current.sunset ? new Date(current.sunset) : null
        },
        location: raw.location,
        hourly: raw.hourly.map(h => ({
          ...h,
          date: new Date(h.date)
        })),
        dailyPeriods: (raw.dailyPeriods || []).map(p => ({
          ...p,
          startTime: p.startTime
        }))
      };
    }
    function loadWeatherCache(lat, lon){
      try {
        const key = getWeatherCacheKey(lat, lon);
        const raw = localStorage.getItem(key);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || !parsed.fetchedAt || !parsed.data) return null;
        if (Date.now() - parsed.fetchedAt > WEATHER_CACHE_MS) return null;
        const revived = reviveWeatherData(parsed.data);
        if (!revived || !revived.hourly || revived.hourly.length < MIN_HOURLY_POINTS) return null;
        return revived;
      } catch {
        return null;
      }
    }
    function saveWeatherCache(lat, lon, data){
      try {
        const key = getWeatherCacheKey(lat, lon);
        const payload = {
          fetchedAt: Date.now(),
          data: data
        };
        localStorage.setItem(key, JSON.stringify(payload));
      } catch {
        // Ignore cache write errors (e.g., storage full or disabled)
      }
    }
    function loadGeoCache(){
      try {
        const raw = localStorage.getItem(getGeoCacheKey());
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || !parsed.fetchedAt || !parsed.coords) return null;
        if (Date.now() - parsed.fetchedAt > GEO_CACHE_MS) return null;
        return parsed.coords;
      } catch {
        return null;
      }
    }
    function saveGeoCache(coords){
      try {
        const payload = { fetchedAt: Date.now(), coords: coords };
        localStorage.setItem(getGeoCacheKey(), JSON.stringify(payload));
      } catch {
        // Ignore cache write errors
      }
    }
    function getSunTimes(date, lat, lon){
      const rad = Math.PI / 180;
      const toJulian = (d) => d.getTime() / 86400000 - 0.5 + 2440588;
      const fromJulian = (j) => new Date((j + 0.5 - 2440588) * 86400000);
      const J2000 = 2451545;
      const toDays = (d) => toJulian(d) - J2000;
      const e = rad * 23.4397;
      const rightAscension = (l, b) => Math.atan2(Math.sin(l) * Math.cos(e) - Math.tan(b) * Math.sin(e), Math.cos(l));
      const declination = (l, b) => Math.asin(Math.sin(b) * Math.cos(e) + Math.cos(b) * Math.sin(e) * Math.sin(l));
      const solarMeanAnomaly = (d) => rad * (357.5291 + 0.98560028 * d);
      const eclipticLongitude = (M) => {
        const C = rad * (1.9148 * Math.sin(M) + 0.02 * Math.sin(2 * M) + 0.0003 * Math.sin(3 * M));
        const P = rad * 102.9372;
        return M + C + P + Math.PI;
      };
      const julianCycle = (d, lw) => Math.round(d - 0.0009 - lw / (2 * Math.PI));
      const approxTransit = (Ht, lw, n) => 0.0009 + (Ht + lw) / (2 * Math.PI) + n;
      const solarTransitJ = (ds, M, L) => J2000 + ds + 0.0053 * Math.sin(M) - 0.0069 * Math.sin(2 * L);
      const hourAngle = (h, phi, dec) => Math.acos((Math.sin(h) - Math.sin(phi) * Math.sin(dec)) / (Math.cos(phi) * Math.cos(dec)));
      const getSetJ = (h, lw, phi, dec, n, M, L) => {
        const w = hourAngle(h, phi, dec);
        const a = approxTransit(w, lw, n);
        return solarTransitJ(a, M, L);
      };

      const lw = rad * -lon;
      const phi = rad * lat;
      const d = toDays(date);
      const n = julianCycle(d, lw);
      const ds = approxTransit(0, lw, n);
      const M = solarMeanAnomaly(ds);
      const L = eclipticLongitude(M);
      const dec = declination(L, 0);
      const Jnoon = solarTransitJ(ds, M, L);
      const h0 = rad * -0.833;
      const Jset = getSetJ(h0, lw, phi, dec, n, M, L);
      const Jrise = Jnoon - (Jset - Jnoon);
      return { sunrise: fromJulian(Jrise), sunset: fromJulian(Jset) };
    }

    function formatTime(d){
      let h = d.getHours();
      let m = d.getMinutes();
      let s = d.getSeconds();
      if(use24h){
        return `${pad(h)}:${pad(m)}:${pad(s)}`;
      } else {
        const ampm = h >= 12 ? 'PM' : 'AM';
        h = h % 12; if(h === 0) h = 12;
        return `${h}:${pad(m)}:${pad(s)} ${ampm}`;
      }
    }

    function formatDate(d){
      return d.toLocaleDateString(undefined, { weekday:'short', month:'short', day:'numeric', year:'numeric' });
    }

    function tick(){
      const now = new Date();
      timeEl.textContent = formatTime(now);
      dateEl.textContent = formatDate(now);
      renderWeatherClock();
    }

    // ---------- Calendar ----------
    function initCalendar(){
      const now = new Date();
      viewYear = now.getFullYear();
      viewMonth = now.getMonth();
      renderCalendar();
    }

    function renderCalendar(){
      const now = new Date();
      const todayYear = now.getFullYear();
      const todayMonth = now.getMonth();
      const todayDate = now.getDate();

      calGrid.innerHTML = '';

      const dayNames = ['Su','Mo','Tu','We','Th','Fr','Sa'];
      dayNames.forEach(d => {
        const el = document.createElement('div');
        el.className = 'calHeader';
        el.textContent = d;
        calGrid.appendChild(el);
      });

      const firstDay = new Date(viewYear, viewMonth, 1).getDay();
      const daysInMonth = new Date(viewYear, viewMonth + 1, 0).getDate();
      const daysInPrevMonth = new Date(viewYear, viewMonth, 0).getDate();

      for(let i = firstDay - 1; i >= 0; i--){
        const el = document.createElement('div');
        el.className = 'calDay otherMonth';
        el.textContent = daysInPrevMonth - i;
        calGrid.appendChild(el);
      }

      for(let d = 1; d <= daysInMonth; d++){
        const el = document.createElement('div');
        el.className = 'calDay';
        if(viewYear === todayYear && viewMonth === todayMonth && d === todayDate){
          el.classList.add('today');
        }
        el.textContent = d;
        calGrid.appendChild(el);
      }

      const totalCells = calGrid.children.length;
      const remaining = 49 - totalCells;
      for(let d = 1; d <= remaining; d++){
        const el = document.createElement('div');
        el.className = 'calDay otherMonth';
        el.textContent = d;
        calGrid.appendChild(el);
      }
    }

    function prevMonth(){
      viewMonth--;
      if(viewMonth < 0){ viewMonth = 11; viewYear--; }
      renderCalendar();
    }

    function nextMonth(){
      viewMonth++;
      if(viewMonth > 11){ viewMonth = 0; viewYear++; }
      renderCalendar();
    }

    function goToToday(){
      const now = new Date();
      viewYear = now.getFullYear();
      viewMonth = now.getMonth();
      renderCalendar();
    }

    // ---------- Weather ----------
    function getWeatherIcon(weatherStr) {
      const lower = weatherStr.toLowerCase();
      if (lower.includes('snow')) return '‚ùÑÔ∏è';
      if (lower.includes('rain') || lower.includes('shower')) return 'üåßÔ∏è';
      if (lower.includes('cloud') || lower.includes('overcast')) return '‚òÅÔ∏è';
      if (lower.includes('clear') || lower.includes('sunny')) return '‚òÄÔ∏è';
      if (lower.includes('partly')) return '‚õÖ';
      return '‚òÄÔ∏è';
    }

    async function fetchWeather() {
      try {
        // Get geolocation
        return new Promise((resolve) => {
          const cachedCoords = loadGeoCache();
          const useCoords = cachedCoords || null;
          const onCoords = async (coords) => {
            const { latitude, longitude } = coords;

            const cached = loadWeatherCache(latitude, longitude);
            if (cached) {
              const computed = computePrecipSummary(cached.hourly, latitude, longitude);
              cached.current = cached.current || {};
              cached.current.precipSummary = computed.summary;
              cached.current.sunrise = computed.sunrise;
              cached.current.sunset = computed.sunset;
              saveWeatherCache(latitude, longitude, cached);
              weatherData = cached;
              renderCurrentWeather();
              renderWeatherClock();
              renderChart();
              resolve();
              return;
            }
            
            try {
              // Get point data from weather.gov
              const pointsRes = await fetch(`https://api.weather.gov/points/${latitude},${longitude}`);
              const pointsData = await pointsRes.json();
              
              const forecastUrl = pointsData.properties.forecast;
              const forecastHourlyUrl = pointsData.properties.forecastHourly;
              const forecastGridUrl = pointsData.properties.forecastGridData;
              const location = pointsData.properties.relativeLocation.properties;
              
              // Get forecast data for current conditions
              const forecastRes = await fetch(forecastUrl);
              const forecastData = await forecastRes.json();
              
              // Get hourly forecast for the chart
              const hourlyRes = await fetch(forecastHourlyUrl);
              const hourlyData = await hourlyRes.json();
              
              // Get grid forecast for quantitative precipitation (accumulation)
              let precipByHour = {};
              if (forecastGridUrl) {
                try {
                  const gridRes = await fetch(forecastGridUrl);
                  const gridData = await gridRes.json();
                  const qpfValues = gridData?.properties?.quantitativePrecipitation?.values || [];
                  qpfValues.forEach(entry => {
                    if (!entry || entry.value === null || entry.value === undefined) return;
                    const startStr = String(entry.validTime || '').split('/')[0];
                    if (!startStr) return;
                    const start = new Date(startStr);
                    if (Number.isNaN(start.getTime())) return;
                    const key = hourKeyFromDate(start);
                    // API returns mm; convert to inches
                    precipByHour[key] = entry.value / 25.4;
                  });
                } catch (err) {
                  console.error('Forecast grid data error:', err);
                }
              }
              
              // Extract current conditions (prefer hourly for "now")
              const hourlyPeriods = hourlyData.properties.periods;
              const currentHour = hourlyPeriods[0];
              const temp = currentHour.temperature;
              const shortForecast = currentHour.shortForecast;
              
              // Build a fixed 168-hour window (169 hourly points) from the current hour.
              // This keeps day-width scaling stable even if the upstream feed has gaps.
              const sourceHourly = hourlyPeriods.map(period => {
                const date = new Date(period.startTime);
                const key = hourKeyFromDate(date);
                return {
                  date: date,
                  key: key,
                  temp: period.temperature,
                  precip: period.probabilityOfPrecipitation.value || 0,
                  precipAmountIn: precipByHour[key] ?? null,
                  isDaytime: period.isDaytime,
                  shortForecast: period.shortForecast || ''
                };
              }).filter(h => !Number.isNaN(h.date.getTime()));

              const sourceByHour = new Map(sourceHourly.map(h => [h.key, h]));
              const startHour = new Date();
              startHour.setMinutes(0, 0, 0);
              const horizonHours = 168;
              const hourly = [];
              let lastKnown = sourceHourly.length ? sourceHourly[0] : null;
              for (let i = 0; i <= horizonHours; i++) {
                const slotDate = new Date(startHour.getTime() + i * 60 * 60 * 1000);
                const slotKey = hourKeyFromDate(slotDate);
                const exact = sourceByHour.get(slotKey);
                if (exact) {
                  lastKnown = exact;
                }
                if (!lastKnown) continue;
                hourly.push({
                  date: slotDate,
                  temp: lastKnown.temp,
                  precip: lastKnown.precip,
                  precipAmountIn: lastKnown.precipAmountIn,
                  isDaytime: lastKnown.isDaytime,
                  shortForecast: lastKnown.shortForecast
                });
              }
              
              weatherData = {
                current: {
                  temp: temp,
                  description: shortForecast,
                  icon: getWeatherIcon(shortForecast),
                  precipSummary: '--% | --in',
                  sunrise: null,
                  sunset: null
                },
                hourly: hourly,
                dailyPeriods: forecastData.properties.periods || [],
                location: `${location.city}, ${location.state}`
              };

              // Compute "rest of day" precip summary
              const computed = computePrecipSummary(hourly, latitude, longitude);
              weatherData.current.precipSummary = computed.summary;
              weatherData.current.sunrise = computed.sunrise;
              weatherData.current.sunset = computed.sunset;
              
              renderCurrentWeather();
              renderWeatherClock();
              renderChart();
              saveWeatherCache(latitude, longitude, weatherData);
            } catch (err) {
              console.error('Weather.gov API error:', err);
            }
            resolve();
          };

          if (useCoords) {
            onCoords(useCoords);
            return;
          }

          navigator.geolocation.getCurrentPosition((position) => {
            saveGeoCache(position.coords);
            onCoords(position.coords);
          }, () => {
            console.log('Geolocation denied');
            resolve();
          });
        });
      } catch (err) {
        console.error('Weather fetch error:', err);
      }
    }

    function renderCurrentWeather(){
      weatherIcon.textContent = weatherData.current.icon;
      currentTemp.textContent = weatherData.current.temp + '¬∞F';
      currentPrecipSummary.textContent = weatherData.current.precipSummary || '--% | --in';
      if (weatherData.location) {
        weatherLocation.textContent = weatherData.location;
      }
    }

    function computePrecipSummary(hourly, lat, lon){
      const now = new Date();
      const endOfDay = new Date(now);
      endOfDay.setHours(23, 59, 59, 999);
      let maxPrecip = 0;
      let accumIn = 0;
      let accumCount = 0;
      hourly.forEach(h => {
        if (h.date >= now && h.date <= endOfDay) {
          maxPrecip = Math.max(maxPrecip, h.precip || 0);
          if (h.precipAmountIn !== null) {
            accumIn += h.precipAmountIn;
            accumCount += 1;
          }
        }
      });
      const accumText = accumCount ? formatInches(accumIn) + 'in' : '‚Äî';
      const sunTimes = getSunTimes(now, lat, lon);
      return {
        summary: `${Math.round(maxPrecip)}% | ${accumText}`,
        sunrise: sunTimes.sunrise,
        sunset: sunTimes.sunset
      };
    }

    function buildDailySummaries(hourly, dailyPeriods){
      const byDay = new Map();
      hourly.forEach(h => {
        const d = h.date;
        const key = `${d.getFullYear()}-${d.getMonth()}-${d.getDate()}`;
        if (!byDay.has(key)) {
          byDay.set(key, {
            date: new Date(d.getFullYear(), d.getMonth(), d.getDate()),
            minTemp: h.temp,
            maxTemp: h.temp,
            precipMax: h.precip || 0,
            accumIn: h.precipAmountIn !== null ? h.precipAmountIn : 0,
            accumCount: h.precipAmountIn !== null ? 1 : 0,
            iconCounts: { [getWeatherIcon(h.shortForecast || '')]: 1 }
          });
          return;
        }
        const s = byDay.get(key);
        s.minTemp = Math.min(s.minTemp, h.temp);
        s.maxTemp = Math.max(s.maxTemp, h.temp);
        s.precipMax = Math.max(s.precipMax, h.precip || 0);
        if (h.precipAmountIn !== null) {
          s.accumIn += h.precipAmountIn;
          s.accumCount += 1;
        }
        const icon = getWeatherIcon(h.shortForecast || '');
        s.iconCounts[icon] = (s.iconCounts[icon] || 0) + 1;
      });

      (dailyPeriods || []).forEach((p, idx, arr) => {
        if (!p || !p.isDaytime || !p.startTime) return;
        const d = new Date(p.startTime);
        if (Number.isNaN(d.getTime())) return;
        const key = `${d.getFullYear()}-${d.getMonth()}-${d.getDate()}`;
        if (byDay.has(key)) return;
        const next = arr[idx + 1];
        const low = next && !next.isDaytime && typeof next.temperature === 'number'
          ? next.temperature
          : p.temperature;
        const precip = p.probabilityOfPrecipitation && p.probabilityOfPrecipitation.value
          ? p.probabilityOfPrecipitation.value
          : 0;
        byDay.set(key, {
          date: new Date(d.getFullYear(), d.getMonth(), d.getDate()),
          minTemp: low,
          maxTemp: p.temperature,
          precipMax: precip,
          accumIn: 0,
          accumCount: 0,
          iconCounts: { [getWeatherIcon(p.shortForecast || '')]: 1 }
        });
      });

      return Array.from(byDay.values()).sort((a, b) => a.date - b.date);
    }

    function renderWeatherClock(){
      if (!weatherClock || !currentWeather) return;
      const size = Math.min(currentWeather.clientWidth, currentWeather.clientHeight);
      if (size <= 0) return;
      weatherClock.setAttribute('viewBox', '0 0 100 100');
      while (weatherClock.firstChild) weatherClock.removeChild(weatherClock.firstChild);

      const ns = 'http://www.w3.org/2000/svg';
      function angleFromDate(d){
        const hours = d.getHours() + d.getMinutes() / 60 + d.getSeconds() / 3600;
        return ((hours - 12) / 24) * 360 - 90;
      }
      function pointOnCircle(r, angleDeg){
        const a = (Math.PI / 180) * angleDeg;
        return { x: 50 + r * Math.cos(a), y: 50 + r * Math.sin(a) };
      }
      function describeArc(r, startDeg, endDeg){
        const start = pointOnCircle(r, startDeg);
        const end = pointOnCircle(r, endDeg);
        const sweep = ((endDeg - startDeg + 360) % 360);
        const largeArc = sweep > 180 ? 1 : 0;
        return `M ${start.x.toFixed(2)} ${start.y.toFixed(2)} A ${r} ${r} 0 ${largeArc} 1 ${end.x.toFixed(2)} ${end.y.toFixed(2)}`;
      }

      const circle = document.createElementNS(ns, 'circle');
      circle.setAttribute('cx', '50');
      circle.setAttribute('cy', '50');
      circle.setAttribute('r', '46');
      circle.setAttribute('fill', 'none');
      circle.setAttribute('stroke', '#ff4444');
      circle.setAttribute('stroke-width', '1.2');
      weatherClock.appendChild(circle);

      if (weatherData.current && weatherData.current.sunrise && weatherData.current.sunset) {
        const sunrise = new Date(weatherData.current.sunrise);
        const sunset = new Date(weatherData.current.sunset);
        if (!Number.isNaN(sunrise.getTime()) && !Number.isNaN(sunset.getTime())) {
          const sunriseDeg = angleFromDate(sunrise);
          const sunsetDeg = angleFromDate(sunset);
          const arcSweep = ((sunsetDeg - sunriseDeg + 360) % 360);
          const endDeg = sunriseDeg + Math.min(180, arcSweep);
          const arc = document.createElementNS(ns, 'path');
          arc.setAttribute('d', describeArc(46, sunriseDeg, endDeg));
          arc.setAttribute('fill', 'none');
          arc.setAttribute('stroke', 'rgba(255, 196, 64, 0.9)');
          arc.setAttribute('stroke-width', '1.2');
          arc.setAttribute('stroke-linecap', 'round');
          weatherClock.appendChild(arc);
        }
      }

      for (let h = 0; h < 24; h++) {
        const angleDeg = ((h - 12) / 24) * 360 - 90;
        const angle = (Math.PI / 180) * angleDeg;
        const isMajor = h % 6 === 0 || h % 6 === 3;
        const rOuter = 46;
        const rInner = isMajor ? 40 : 42.5;
        const x1 = 50 + rInner * Math.cos(angle);
        const y1 = 50 + rInner * Math.sin(angle);
        const x2 = 50 + rOuter * Math.cos(angle);
        const y2 = 50 + rOuter * Math.sin(angle);
        const tick = document.createElementNS(ns, 'line');
        tick.setAttribute('x1', x1.toFixed(2));
        tick.setAttribute('y1', y1.toFixed(2));
        tick.setAttribute('x2', x2.toFixed(2));
        tick.setAttribute('y2', y2.toFixed(2));
        let tickColor = '#ff4444';
        if (weatherData.current && weatherData.current.sunrise && weatherData.current.sunset) {
          const sunrise = new Date(weatherData.current.sunrise);
          const sunset = new Date(weatherData.current.sunset);
          if (!Number.isNaN(sunrise.getTime()) && !Number.isNaN(sunset.getTime())) {
            const tickDeg = angleDeg;
            const sunriseDeg = angleFromDate(sunrise);
            const sunsetDeg = angleFromDate(sunset);
            const sweep = ((sunsetDeg - sunriseDeg + 360) % 360);
            const rel = ((tickDeg - sunriseDeg + 360) % 360);
            if (rel >= 0 && rel <= sweep) {
              tickColor = 'rgba(255, 196, 64, 0.9)';
            }
          }
        }
        tick.setAttribute('stroke', tickColor);
        tick.setAttribute('stroke-width', isMajor ? '1.6' : '1');
        weatherClock.appendChild(tick);
      }

      // Current time triangle marker
      const now = new Date();
      const nowDeg = angleFromDate(now);
      const tip = pointOnCircle(40, nowDeg);
      const baseA = pointOnCircle(48, nowDeg - 1.4);
      const baseB = pointOnCircle(48, nowDeg + 1.4);
      const tri = document.createElementNS(ns, 'polygon');
      tri.setAttribute('points', `${tip.x.toFixed(2)},${tip.y.toFixed(2)} ${baseA.x.toFixed(2)},${baseA.y.toFixed(2)} ${baseB.x.toFixed(2)},${baseB.y.toFixed(2)}`);
      tri.setAttribute('fill', 'rgba(230, 236, 245, 0.98)');
      tri.setAttribute('stroke', 'rgba(230, 236, 245, 0.98)');
      tri.setAttribute('stroke-width', '0.6');
      weatherClock.appendChild(tri);
    }

    // ---------- Chart ----------
    function renderChart(){
      const ctx = chartCanvas.getContext('2d');
      const width = chartCanvas.offsetWidth;
      const height = chartCanvas.offsetHeight;
      
      chartCanvas.width = width;
      chartCanvas.height = height;
      
      const paddingLeft = 48;
      const paddingRight = 52;
      const paddingTop = 152;
      const paddingBottom = 10;
      const chartWidth = width - paddingLeft - paddingRight;
      const chartHeight = height - paddingTop - paddingBottom;
      const data = weatherData.hourly;
      
      if (data.length === 0) return; // No data yet

      
      // Calculate min/max for axes
      const temps = data.map(d => d.temp);
      const precips = data.map(d => d.precip);
      const minTemp = Math.min(...temps);
      const maxTemp = Math.max(...temps);
      const minPrecip = 0;
      const maxPrecip = 100;
      
      // Helper functions
      function tempToY(temp) {
        return height - paddingBottom - ((temp - minTemp) / (maxTemp - minTemp)) * chartHeight;
      }
      
      function precipToY(precip) {
        return height - paddingBottom - (precip / maxPrecip) * chartHeight;
      }
      
      function hourToX(index) {
        return paddingLeft + (index / (data.length - 1)) * chartWidth;
      }

      // Shade alternating days across the full chart panel (labels + chart)
      let shadePrevDate = null;
      let shadeDayStartIdx = 0;
      let dayIndex = 0;
      for (let i = 0; i <= data.length; i++) {
        const currentDate = i < data.length ? data[i].date : null;
        const isTransition = i === data.length || !shadePrevDate || (currentDate && currentDate.getDate() !== shadePrevDate.getDate());
        if (isTransition && shadePrevDate) {
          const dayEndX = i < data.length ? hourToX(i) : width - paddingRight;
          const dayStartX = hourToX(shadeDayStartIdx);
          if (dayIndex % 2 === 1) {
            ctx.fillStyle = '#242424';
            ctx.fillRect(dayStartX, 0, dayEndX - dayStartX, height);
          }
          if (i < data.length) {
            const boundaryX = hourToX(i);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.14)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(boundaryX, 0);
            ctx.lineTo(boundaryX, height);
            ctx.stroke();
          }
          dayIndex += 1;
          shadeDayStartIdx = i;
        }
        if (currentDate) {
          shadePrevDate = currentDate;
        }
      }
      
      // Draw horizontal grid lines for precipitation (0%, 50%, 100%)
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.lineWidth = 1;
      const precipGridLines = [0, 50, 100];
      precipGridLines.forEach(precip => {
        const y = precipToY(precip);
        ctx.beginPath();
        ctx.moveTo(paddingLeft, y);
        ctx.lineTo(width - paddingRight, y);
        ctx.stroke();
      });
      
      // Day transitions are shown via alternating tinting.
      
      // Draw axes
      ctx.strokeStyle = 'rgba(192, 25, 25, 0.3)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(paddingLeft, paddingTop);
      ctx.lineTo(paddingLeft, height - paddingBottom);
      ctx.lineTo(width - paddingRight, height - paddingBottom);
      ctx.stroke();

      // Draw freezing reference line at 32F
      const freezingY = tempToY(32);
      ctx.save();
      ctx.strokeStyle = 'rgba(160, 160, 160, 0.8)';
      ctx.lineWidth = 1;
      ctx.setLineDash([6, 4]);
      ctx.beginPath();
      ctx.moveTo(paddingLeft, freezingY);
      ctx.lineTo(width - paddingRight, freezingY);
      ctx.stroke();
      ctx.restore();

      // Draw red tick marks on x-axis at midnight/6am/noon/6pm
      ctx.strokeStyle = 'rgba(255, 68, 68, 0.55)';
      ctx.lineWidth = 1;
      data.forEach((d, i) => {
        const h = d.date.getHours();
        if (h === 0 || h === 6 || h === 12 || h === 18) {
          const x = hourToX(i);
          ctx.beginPath();
          ctx.moveTo(x, height - paddingBottom);
          ctx.lineTo(x, height - paddingBottom + 8);
          ctx.stroke();
        }
      });
      
      // Draw temperature line
      ctx.strokeStyle = '#ff4444';
      ctx.lineWidth = 2;
      ctx.beginPath();
      data.forEach((d, i) => {
        const x = hourToX(i);
        const y = tempToY(d.temp);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();
      
      // Draw temperature gradient background
      const tempGradient = ctx.createLinearGradient(0, paddingTop, 0, height - paddingBottom);
      tempGradient.addColorStop(0, 'rgba(255, 68, 68, 0.2)');
      tempGradient.addColorStop(1, 'rgba(255, 68, 68, 0.05)');
      ctx.fillStyle = tempGradient;
      ctx.beginPath();
      data.forEach((d, i) => {
        const x = hourToX(i);
        const y = tempToY(d.temp);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.lineTo(width - paddingRight, height - paddingBottom);
      ctx.lineTo(paddingLeft, height - paddingBottom);
      ctx.fill();
      
      // Draw precipitation line
      ctx.strokeStyle = '#4488ff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      data.forEach((d, i) => {
        const x = hourToX(i);
        const y = precipToY(d.precip);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();
      
      // Draw precipitation gradient background
      const precipGradient = ctx.createLinearGradient(0, paddingTop, 0, height - paddingBottom);
      precipGradient.addColorStop(0, 'rgba(68, 136, 255, 0.15)');
      precipGradient.addColorStop(1, 'rgba(68, 136, 255, 0.02)');
      ctx.fillStyle = precipGradient;
      ctx.beginPath();
      data.forEach((d, i) => {
        const x = hourToX(i);
        const y = precipToY(d.precip);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.lineTo(width - paddingRight, height - paddingBottom);
      ctx.lineTo(paddingLeft, height - paddingBottom);
      ctx.fill();
      
      // Draw day labels and markers at midnight transitions
      ctx.font = '12px arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      
      previousDate = null;
      let dayStartIdx = 0;
      let dayCardsDrawn = 0;
      const nowForCards = new Date();
      const startOfToday = new Date(nowForCards.getFullYear(), nowForCards.getMonth(), nowForCards.getDate());
      const hideCurrentDayCard = nowForCards.getHours() >= 12;
      const maxDayCards = hideCurrentDayCard ? (nowForCards.getHours() >= 15 ? 7 : 6) : 7;
      const minDayCardWidth = 72;
      
      for (let i = 0; i <= data.length; i++) {
        const currentDate = i < data.length ? data[i].date : null;
        const isTransition = i === data.length || !previousDate || (currentDate && currentDate.getDate() !== previousDate.getDate());
        
        if (isTransition && previousDate) {
          // Calculate day bounds
          const dayEndIdx = i;
          const dayDate = data[dayStartIdx].date;
          const dayStartX = hourToX(dayStartIdx);
          const dayEndX = i < data.length ? hourToX(i) : width - paddingRight;
          const dayWidth = dayEndX - dayStartX;
          const dayMidX = (dayStartX + dayEndX) / 2;
          const isTodayCard =
            dayDate.getFullYear() === nowForCards.getFullYear() &&
            dayDate.getMonth() === nowForCards.getMonth() &&
            dayDate.getDate() === nowForCards.getDate();
          const isPastDayCard = dayDate < startOfToday;
          const isTooNarrowForCard = dayWidth < minDayCardWidth;
          const shouldSkipCard = isPastDayCard || isTooNarrowForCard || dayCardsDrawn >= maxDayCards || (hideCurrentDayCard && isTodayCard);
          
          if (!shouldSkipCard) {
            // Find min/max temps for this day
            let dayMinTemp = Infinity;
            let dayMaxTemp = -Infinity;
            let dayPrecipMax = 0;
            let dayAccumIn = 0;
            let dayAccumCount = 0;
            const iconCounts = {};
            for (let j = dayStartIdx; j < dayEndIdx; j++) {
              dayMinTemp = Math.min(dayMinTemp, data[j].temp);
              dayMaxTemp = Math.max(dayMaxTemp, data[j].temp);
              const icon = getWeatherIcon(data[j].shortForecast || '');
              iconCounts[icon] = (iconCounts[icon] || 0) + 1;
              dayPrecipMax = Math.max(dayPrecipMax, data[j].precip || 0);
              if (data[j].precipAmountIn !== null) {
                dayAccumIn += data[j].precipAmountIn;
                dayAccumCount += 1;
              }
            }
            
            // Choose the most common icon for the day
            let dayIcon = '‚òÄÔ∏è';
            let bestCount = -1;
            Object.keys(iconCounts).forEach(icon => {
              if (iconCounts[icon] > bestCount) {
                bestCount = iconCounts[icon];
                dayIcon = icon;
              }
            });
            
            // Draw day label in white (top of panel)
            ctx.fillStyle = 'rgba(255, 255, 255, 1)';
            ctx.font = '18px arial';
            const dayName = dayDate.toLocaleDateString(undefined, { weekday: 'short', month: 'numeric', day: 'numeric' }).replace(', ', ' ');
            ctx.textBaseline = 'top';
            ctx.fillText(dayName, dayMidX, 8);
            
            // Draw low/high temps on one line: "Lo/Hi"
            ctx.font = 'bold 16px arial';
            const tempText = Math.round(dayMinTemp) + '¬∞ | ' + Math.round(dayMaxTemp) + '¬∞ F';
            ctx.fillText(tempText, dayMidX, 32);
            
            // Draw overall daily forecast icon below temps
            ctx.font = '36px arial';
            ctx.fillText(dayIcon, dayMidX, 66);
            
            // Draw predicted precipitation forecast below icon
            const dayPrecipDisplay = Math.round(dayPrecipMax);
            const dayAccumText = dayAccumCount ? formatInches(dayAccumIn) + 'in' : '‚Äî';
            ctx.font = '16px arial';
            ctx.fillText(dayPrecipDisplay + '% | ' + dayAccumText, dayMidX, 112);
            dayCardsDrawn += 1;
          }
          
          dayStartIdx = i;
        }
        
        if (currentDate) {
          previousDate = currentDate;
        }
      }
      
      // Draw dots at every 6 hours for clarity
      previousDate = null;
      data.forEach((d, i) => {
        if (i % 6 === 0) {
          ctx.fillStyle = '#ff4444';
          ctx.beginPath();
          ctx.arc(hourToX(i), tempToY(d.temp), 2, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.fillStyle = '#4488ff';
          ctx.beginPath();
          ctx.arc(hourToX(i), precipToY(d.precip), 2, 0, Math.PI * 2);
          ctx.fill();
        }
      });
      
      // Draw axis labels
      ctx.fillStyle = 'rgba(255, 100, 100, 1)';
      ctx.font = 'bold 16px arial';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      const tempTicks = [minTemp, (minTemp + maxTemp) / 2, maxTemp];
      tempTicks.forEach(temp => {
        const y = tempToY(temp);
      ctx.fillText(Math.round(temp) + '¬∞', paddingLeft - 8, y);
      });
      
      ctx.fillStyle = 'rgba(100, 180, 255, 1)';
      ctx.font = 'bold 16px arial';
      ctx.textAlign = 'left';
      const precipTicks = [0, 50, 100];
      precipTicks.forEach(precip => {
        const y = precipToY(precip);
        ctx.fillText(precip + '%', width - paddingRight + 8, y);
      });

      // Hover marker line
      if (chartHoverIndex !== null && chartHoverIndex >= 0 && chartHoverIndex < data.length) {
        const x = hourToX(chartHoverIndex);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.55)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, paddingTop);
        ctx.lineTo(x, height - paddingBottom);
        ctx.stroke();

        const hoverTempY = tempToY(data[chartHoverIndex].temp);
        const hoverPrecipY = precipToY(data[chartHoverIndex].precip);

        // Temp intersection
        ctx.fillStyle = '#ff6b6b';
        ctx.beginPath();
        ctx.arc(x, hoverTempY, 4, 0, Math.PI * 2);
        ctx.fill();

        // Precip intersection
        ctx.fillStyle = '#6bb6ff';
        ctx.beginPath();
        ctx.arc(x, hoverPrecipY, 4, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function setupChartHover(){
      chartCanvas.addEventListener('mousemove', (e) => {
        const rect = chartCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const data = weatherData.hourly;
        if (!data || data.length === 0) return;

        const paddingLeft = 48;
        const paddingRight = 52;
        const paddingTop = 152;
        const paddingBottom = 40;
        const width = rect.width;
        const height = rect.height;
        const chartWidth = width - paddingLeft - paddingRight;
        const chartHeight = height - paddingTop - paddingBottom;

        if (x < paddingLeft || x > width - paddingRight || y < 0 || y > height) {
          chartTooltip.style.display = 'none';
          return;
        }

        const rawIndex = Math.round(((x - paddingLeft) / chartWidth) * (data.length - 1));
        const idx = Math.max(0, Math.min(data.length - 1, rawIndex));
        chartHoverIndex = idx;
        const point = data[idx];

        const timeLabel = point.date.toLocaleString(undefined, {
          weekday: 'short',
          month: 'numeric',
          day: 'numeric',
          hour: 'numeric',
          minute: '2-digit'
        });
        const tempLabel = Math.round(point.temp) + '¬∞F';
        const precipLabel = (point.precip || 0) + '%';
        chartTooltip.innerHTML = `${timeLabel}<br>${tempLabel} ‚Ä¢ ${precipLabel}`;
        chartTooltip.style.display = 'block';

        const offsetX = 12;
        const offsetY = -12;
        chartTooltip.style.left = `${e.clientX + offsetX}px`;
        chartTooltip.style.top = `${e.clientY + offsetY}px`;
        renderChart();
      });

      chartCanvas.addEventListener('mouseleave', () => {
        chartTooltip.style.display = 'none';
        chartHoverIndex = null;
        renderChart();
      });
    }

    // ---------- Event Listeners ----------
    document.getElementById('prevMonth').addEventListener('click', (e) => { e.stopPropagation(); prevMonth(); });
    document.getElementById('nextMonth').addEventListener('click', (e) => { e.stopPropagation(); nextMonth(); });
    dateEl.addEventListener('click', (e) => { e.stopPropagation(); goToToday(); });

    // ---------- Dimmer ----------
    function setDim(newDim){
      dim = Math.min(0.80, Math.max(0.0, newDim));
      document.documentElement.style.setProperty('--dim', dim.toFixed(2));
    }

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      const key = e.key.toLowerCase();
      if(key === '+' || key === '=') setDim(dim + 0.05);
      if(key === '-' || key === '_') setDim(dim - 0.05);
      if(key === '?'){ help.style.display = (help.style.display === 'none' ? 'block' : 'none'); }
      if(key === 't'){ use24h = !use24h; tick(); }
      if(key === 'arrowleft') prevMonth();
      if(key === 'arrowright') nextMonth();
      if(key === 'home' || key === 'h') goToToday();
    });

    document.addEventListener('click', () => help.style.display = 'none');

    // ---------- Initialize ----------
    function init(){
      tick();
      initCalendar();
      renderCurrentWeather();
      renderWeatherClock();
      renderChart();
      setupChartHover();
      fetchWeather();
      
      setInterval(tick, UPDATE_EVERY_SEC * 1000);
      window.addEventListener('resize', () => {
        renderChart();
        renderWeatherClock();
      });
      
      // Refresh weather every 30 minutes
      setInterval(fetchWeather, 30 * 60 * 1000);
    }

    // Re-render calendar at midnight
    function scheduleNextMidnight(){
      const now = new Date();
      const tomorrow = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);
      const msUntilMidnight = tomorrow - now;
      setTimeout(() => {
        renderCalendar();
        fetchWeather();
        renderChart();
        scheduleNextMidnight();
      }, msUntilMidnight + 1000);
    }

    init();
    scheduleNextMidnight();
  </script>
</body>
</html>
