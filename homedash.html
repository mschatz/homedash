<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ambient Clock</title>
  <style>
    :root{
      --bg: #000000;
      --fg: #c01919; /* deep burgundy (less "laser red") */
      --date: #b21616;
      --font: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;

      /* Software dimmer: higher = darker overall (0.0 to 0.8 is practical) */
      --dim: 0.0;

      /* Clock size: adjust to taste for 5" display */
      --clockSize: 48px;
      --dateSize: 14px;
      --calCellSizeWidth: 40px;
      --calCellSizeHeight: 32px;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      overflow: hidden;
    }

    /* Main container */
    #wrap {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      font-family: var(--font);
      user-select: none;
      padding: 0;
    }

    /* Top section: clock (full width, ~2") */
    #clockSection {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 120px;
      border-bottom: 1px solid rgba(192, 25, 25, 0.2);
      padding: 12px;
    }

    /* Clock block */
    #clockBlock {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      text-align: center;
      letter-spacing: 0.02em;
    }

    #time {
      font-size: 80px;
      color: var(--fg);
      font-weight: 600;
      line-height: 1;
      text-shadow: 0 0 10px rgba(122, 27, 27, 0.08); /* subtle glow */
      white-space: nowrap;
    }

    #date {
      font-size: 28px;
      color: var(--date);
      font-weight: 500;
      opacity: 0.95;
      line-height: 1.2;
    }

    /* Middle section: calendar and current weather (~4") */
    #middleSection {
      display: flex;
      gap: 2px;
      flex: 1;
      min-height: 0;
      min-width: 0;
      padding: 2px;
    }

    /* Calendar */
    #calendar {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      flex: 1 1 0;
      min-width: 0;
      padding: 12px;
      border: 1px solid rgba(192, 25, 25, 0.2);
      border-radius: 8px;
      width: auto;
    }

    #calNav {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
    }

    #calNav button {
      background: transparent;
      border: 1px solid var(--fg);
      color: var(--fg);
      font-family: var(--font);
      font-size: 10px;
      padding: 1px 4px;
      border-radius: 3px;
      cursor: pointer;
      opacity: 0.8;
      transition: opacity 0.2s;
      line-height: 1;
    }

    #calNav button:hover {
      opacity: 1;
    }

    #calMonthYear {
      font-size: clamp(16px, 2.6vw, 20px);
      color: var(--fg);
      font-weight: 600;
      min-width: 100px;
      text-align: center;
    }

    #calGrid {
      display: grid;
      width: 100%;
      grid-template-columns: repeat(7, minmax(0, 1fr));
      gap: 0px;
    }

    .calHeader {
      font-size: clamp(10px, 1.8vw, 13px);
      color: var(--date);
      text-align: center;
      padding: 0px 0;
      font-weight: 600;
      opacity: 0.7;
      line-height: 1;
    }

    .calDay {
      width: 100%;
      height: clamp(22px, 5.2vh, 36px);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(12px, 2.4vw, 18px);
      color: var(--date);
      border-radius: 3px;
      line-height: 1;
    }

    .calDay.otherMonth {
      opacity: 0.5;
    }

    .calDay.today {
      background: var(--fg);
      color: #000;
      font-weight: 700;
    }

    /* Right panel: current weather */
    #currentWeather {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      flex: 1 1 0;
      min-width: 0;
      border: 1px solid rgba(192, 25, 25, 0.3);
      border-radius: 8px;
      padding: 16px;
      gap: 12px;
    }

    #weatherIcon {
      font-size: clamp(32px, 6vw, 48px);
      line-height: 1;
    }

    #currentTemp {
      font-size: clamp(32px, 7vw, 56px);
      color: #ff4444;
      font-weight: 600;
    }

    #weatherDesc {
      font-size: clamp(12px, 2.4vw, 18px);
      color: #888888;
      text-align: center;
    }

    #weatherLocation {
      font-size: clamp(11px, 2.2vw, 16px);
      color: rgba(227, 17, 17, 0.755);
      text-align: center;
    }

    @media (max-width: 700px) {
      #middleSection {
        flex-direction: column;
      }

      #calendar,
      #currentWeather {
        width: 100%;
      }
    }

    /* Bottom section: line chart */
    #chartSection {
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 0;
      gap: 2px;
      padding: 2px;
      border-top: 1px solid rgba(192, 25, 25, 0.2);
    }

    #chartContainer {
      flex: 1;
      min-height: 0;
      position: relative;
    }

    #chart {
      width: 100%;
      height: 100%;
    }

    #chartLegend {
      display: flex;
      justify-content: center;
      gap: 20px;
      font-size: 11px;
      flex-shrink: 0;
    }

    .legendItem {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .legendBox {
      width: 12px;
      height: 12px;
      border-radius: 2px;
    }

    /* Software dim overlay */
    #dim {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,var(--dim));
      pointer-events: none;
    }

    /* Help overlay (hidden by default; toggle with ?) */
    #help {
      position: fixed;
      left: 18px;
      bottom: 14px;
      font-family: var(--font);
      font-size: 12px;
      color: rgba(255,255,255,0.30);
      background: rgba(0,0,0,0.35);
      padding: 8px 10px;
      border-radius: 8px;
      display: none;
      line-height: 1.35;
      max-width: 400px;
    }

    #help kbd{
      font-family: var(--font);
      background: rgba(255,255,255,0.08);
      padding: 1px 5px;
      border-radius: 4px;
      margin: 0 2px;
    }
  </style>
</head>
<body>
  <div id="wrap">
    <!-- Top section: clock (full width, ~2") -->
    <div id="clockSection">
      <div id="clockBlock" aria-label="clock">
        <div id="time">--:--:--</div>
        <div id="date"></div>
      </div>
    </div>

    <!-- Middle section: calendar and current weather side by side (~4") -->
    <div id="middleSection">
      <div id="calendar">
        <div id="calNav">
          <div id="calMonthYear"></div>
          <button id="prevMonth">‚óÄ</button>
          <button id="todayBtn">‚óè</button>
          <button id="nextMonth">‚ñ∂</button>
        </div>
        <div id="calGrid"></div>
      </div>

      <div id="currentWeather">
        <div id="weatherIcon">‚òÄÔ∏è</div>
        <div id="currentTemp">68¬∞F</div>
        <div id="weatherDesc">Partly Cloudy</div>
        <div id="weatherLocation">Loading...</div>
      </div>
    </div>

    <!-- Bottom section: line chart (~2") -->
    <div id="chartSection">
      <div id="chartContainer">
        <canvas id="chart"></canvas>
      </div>
      <div id="chartLegend">
        <div class="legendItem">
          <div class="legendBox" style="background: var(--temp-color);"></div>
          <span>Temperature (¬∞F) ‚Äî Left Axis</span>
        </div>
        <div class="legendItem">
          <div class="legendBox" style="background: var(--precip-color);"></div>
          <span>Precipitation (%) ‚Äî Right Axis</span>
        </div>
      </div>
    </div>
  </div>
  <div id="dim"></div>

  <div id="help">
    <div><strong>Ambient Clock</strong> shortcuts:</div>
    <div>
      <kbd>+</kbd>/<kbd>-</kbd> dimmer &nbsp; ‚Ä¢ &nbsp;
      <kbd>?</kbd> help &nbsp; ‚Ä¢ &nbsp;
      <kbd>t</kbd> 24h
    </div>
    <div style="margin-top:4px;">
      Tip: Full-screen: <kbd>Ctrl</kbd>+<kbd>‚åò</kbd>+<kbd>F</kbd>
    </div>
  </div>

  <script>
    // ---------- Settings ----------
    const UPDATE_EVERY_SEC = 1;
    const USE_24H_DEFAULT = false;

    // ---------- State ----------
    let use24h = USE_24H_DEFAULT;
    let dim = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--dim')) || 0;
    let viewYear, viewMonth;
    let weatherData = {
      current: { temp: '--', description: 'Loading...', icon: '‚òÄÔ∏è' },
      hourly: []
    };

    const timeEl = document.getElementById('time');
    const dateEl = document.getElementById('date');
    const help = document.getElementById('help');
    const calGrid = document.getElementById('calGrid');
    const calMonthYear = document.getElementById('calMonthYear');
    const weatherIcon = document.getElementById('weatherIcon');
    const currentTemp = document.getElementById('currentTemp');
    const weatherDesc = document.getElementById('weatherDesc');
    const weatherLocation = document.getElementById('weatherLocation');
    const chartCanvas = document.getElementById('chart');

    function pad(n){ return String(n).padStart(2,'0'); }

    function formatTime(d){
      let h = d.getHours();
      let m = d.getMinutes();
      let s = d.getSeconds();
      if(use24h){
        return `${pad(h)}:${pad(m)}:${pad(s)}`;
      } else {
        const ampm = h >= 12 ? 'PM' : 'AM';
        h = h % 12; if(h === 0) h = 12;
        return `${h}:${pad(m)}:${pad(s)} ${ampm}`;
      }
    }

    function formatDate(d){
      return d.toLocaleDateString(undefined, { weekday:'short', month:'short', day:'numeric', year:'numeric' });
    }

    function tick(){
      const now = new Date();
      timeEl.textContent = formatTime(now);
      dateEl.textContent = formatDate(now);
    }

    // ---------- Calendar ----------
    function initCalendar(){
      const now = new Date();
      viewYear = now.getFullYear();
      viewMonth = now.getMonth();
      renderCalendar();
    }

    function renderCalendar(){
      const now = new Date();
      const todayYear = now.getFullYear();
      const todayMonth = now.getMonth();
      const todayDate = now.getDate();

      const monthNames = ['January','February','March','April','May','June',
                          'July','August','September','October','November','December'];
      calMonthYear.textContent = `${monthNames[viewMonth]} ${viewYear}`;

      calGrid.innerHTML = '';

      const dayNames = ['Su','Mo','Tu','We','Th','Fr','Sa'];
      dayNames.forEach(d => {
        const el = document.createElement('div');
        el.className = 'calHeader';
        el.textContent = d;
        calGrid.appendChild(el);
      });

      const firstDay = new Date(viewYear, viewMonth, 1).getDay();
      const daysInMonth = new Date(viewYear, viewMonth + 1, 0).getDate();
      const daysInPrevMonth = new Date(viewYear, viewMonth, 0).getDate();

      for(let i = firstDay - 1; i >= 0; i--){
        const el = document.createElement('div');
        el.className = 'calDay otherMonth';
        el.textContent = daysInPrevMonth - i;
        calGrid.appendChild(el);
      }

      for(let d = 1; d <= daysInMonth; d++){
        const el = document.createElement('div');
        el.className = 'calDay';
        if(viewYear === todayYear && viewMonth === todayMonth && d === todayDate){
          el.classList.add('today');
        }
        el.textContent = d;
        calGrid.appendChild(el);
      }

      const totalCells = calGrid.children.length;
      const remaining = 42 - totalCells;
      for(let d = 1; d <= remaining; d++){
        const el = document.createElement('div');
        el.className = 'calDay otherMonth';
        el.textContent = d;
        calGrid.appendChild(el);
      }
    }

    function prevMonth(){
      viewMonth--;
      if(viewMonth < 0){ viewMonth = 11; viewYear--; }
      renderCalendar();
    }

    function nextMonth(){
      viewMonth++;
      if(viewMonth > 11){ viewMonth = 0; viewYear++; }
      renderCalendar();
    }

    function goToToday(){
      const now = new Date();
      viewYear = now.getFullYear();
      viewMonth = now.getMonth();
      renderCalendar();
    }

    // ---------- Weather ----------
    function getWeatherIcon(weatherStr) {
      const lower = weatherStr.toLowerCase();
      if (lower.includes('snow')) return '‚ùÑÔ∏è';
      if (lower.includes('rain') || lower.includes('shower')) return 'üåßÔ∏è';
      if (lower.includes('cloud') || lower.includes('overcast')) return '‚òÅÔ∏è';
      if (lower.includes('clear') || lower.includes('sunny')) return '‚òÄÔ∏è';
      if (lower.includes('partly')) return '‚õÖ';
      return '‚òÄÔ∏è';
    }

    async function fetchWeather() {
      try {
        // Get geolocation
        return new Promise((resolve) => {
          navigator.geolocation.getCurrentPosition(async (position) => {
            const { latitude, longitude } = position.coords;
            
            try {
              // Get point data from weather.gov
              const pointsRes = await fetch(`https://api.weather.gov/points/${latitude},${longitude}`);
              const pointsData = await pointsRes.json();
              
              const forecastUrl = pointsData.properties.forecast;
              const forecastHourlyUrl = pointsData.properties.forecastHourly;
              const location = pointsData.properties.relativeLocation.properties;
              
              // Get forecast data for current conditions
              const forecastRes = await fetch(forecastUrl);
              const forecastData = await forecastRes.json();
              
              // Get hourly forecast for the chart
              const hourlyRes = await fetch(forecastHourlyUrl);
              const hourlyData = await hourlyRes.json();
              
              // Extract current conditions
              const current = forecastData.properties.periods[0];
              const temp = current.temperature;
              const shortForecast = current.shortForecast;
              
              // Build hourly forecast array
              const hourly = hourlyData.properties.periods.slice(0, 168).map(period => ({
                date: new Date(period.startTime),
                temp: period.temperature,
                precip: period.probabilityOfPrecipitation.value || 0,
                isDaytime: period.isDaytime
              }));
              
              weatherData = {
                current: {
                  temp: temp,
                  description: shortForecast,
                  icon: getWeatherIcon(shortForecast)
                },
                hourly: hourly,
                location: `${location.city}, ${location.state}`
              };
              
              renderCurrentWeather();
              renderChart();
            } catch (err) {
              console.error('Weather.gov API error:', err);
            }
            resolve();
          }, () => {
            console.log('Geolocation denied');
            resolve();
          });
        });
      } catch (err) {
        console.error('Weather fetch error:', err);
      }
    }

    function renderCurrentWeather(){
      weatherIcon.textContent = weatherData.current.icon;
      currentTemp.textContent = weatherData.current.temp + '¬∞F';
      weatherDesc.textContent = weatherData.current.description;
      if (weatherData.location) {
        weatherLocation.textContent = weatherData.location;
      }
    }

    // ---------- Chart ----------
    function renderChart(){
      const ctx = chartCanvas.getContext('2d');
      const width = chartCanvas.offsetWidth;
      const height = chartCanvas.offsetHeight;
      
      chartCanvas.width = width;
      chartCanvas.height = height;
      
      const padding = 40;
      const chartWidth = width - 2 * padding;
      const chartHeight = height - 2 * padding;
      const data = weatherData.hourly;
      
      if (data.length === 0) return; // No data yet
      
      // Calculate min/max for axes
      const temps = data.map(d => d.temp);
      const precips = data.map(d => d.precip);
      const minTemp = Math.min(...temps);
      const maxTemp = Math.max(...temps);
      const minPrecip = 0;
      const maxPrecip = 100;
      
      // Helper functions
      function tempToY(temp) {
        return height - padding - ((temp - minTemp) / (maxTemp - minTemp)) * chartHeight;
      }
      
      function precipToY(precip) {
        return height - padding - (precip / maxPrecip) * chartHeight;
      }
      
      function hourToX(index) {
        return padding + (index / (data.length - 1)) * chartWidth;
      }
      
      // Draw horizontal grid lines for precipitation (0%, 50%, 100%)
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.lineWidth = 1;
      const precipGridLines = [0, 50, 100];
      precipGridLines.forEach(precip => {
        const y = precipToY(precip);
        ctx.beginPath();
        ctx.moveTo(padding, y);
        ctx.lineTo(width - padding, y);
        ctx.stroke();
      });
      
      // Draw vertical lines at day transitions
      ctx.strokeStyle = 'rgba(128, 128, 128, 0.5)';
      ctx.lineWidth = 1.5;
      let previousDate = null;
      data.forEach((d, i) => {
        if (previousDate && d.date.getDate() !== previousDate.getDate()) {
          const x = hourToX(i);
          ctx.beginPath();
          ctx.moveTo(x, padding);
          ctx.lineTo(x, height - padding);
          ctx.stroke();
        }
        previousDate = d.date;
      });
      
      // Draw axes
      ctx.strokeStyle = 'rgba(192, 25, 25, 0.3)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(padding, padding);
      ctx.lineTo(padding, height - padding);
      ctx.lineTo(width - padding, height - padding);
      ctx.stroke();
      
      // Draw temperature line
      ctx.strokeStyle = '#ff4444';
      ctx.lineWidth = 2;
      ctx.beginPath();
      data.forEach((d, i) => {
        const x = hourToX(i);
        const y = tempToY(d.temp);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();
      
      // Draw temperature gradient background
      const tempGradient = ctx.createLinearGradient(0, padding, 0, height - padding);
      tempGradient.addColorStop(0, 'rgba(255, 68, 68, 0.2)');
      tempGradient.addColorStop(1, 'rgba(255, 68, 68, 0.05)');
      ctx.fillStyle = tempGradient;
      ctx.beginPath();
      data.forEach((d, i) => {
        const x = hourToX(i);
        const y = tempToY(d.temp);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.lineTo(width - padding, height - padding);
      ctx.lineTo(padding, height - padding);
      ctx.fill();
      
      // Draw precipitation line
      ctx.strokeStyle = '#4488ff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      data.forEach((d, i) => {
        const x = hourToX(i);
        const y = precipToY(d.precip);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();
      
      // Draw precipitation gradient background
      const precipGradient = ctx.createLinearGradient(0, padding, 0, height - padding);
      precipGradient.addColorStop(0, 'rgba(68, 136, 255, 0.15)');
      precipGradient.addColorStop(1, 'rgba(68, 136, 255, 0.02)');
      ctx.fillStyle = precipGradient;
      ctx.beginPath();
      data.forEach((d, i) => {
        const x = hourToX(i);
        const y = precipToY(d.precip);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.lineTo(width - padding, height - padding);
      ctx.lineTo(padding, height - padding);
      ctx.fill();
      
      // Draw day labels and markers at midnight transitions
      ctx.font = '12px monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      
      previousDate = null;
      let dayStartIdx = 0;
      
      for (let i = 0; i <= data.length; i++) {
        const currentDate = i < data.length ? data[i].date : null;
        const isTransition = i === data.length || !previousDate || (currentDate && currentDate.getDate() !== previousDate.getDate());
        
        if (isTransition && previousDate) {
          // Calculate day bounds
          const dayEndIdx = i;
          const dayStartX = hourToX(dayStartIdx);
          const dayEndX = i < data.length ? hourToX(i) : width - padding;
          const dayMidX = (dayStartX + dayEndX) / 2;
          
          // Find min/max temps for this day
          let dayMinTemp = Infinity;
          let dayMaxTemp = -Infinity;
          for (let j = dayStartIdx; j < dayEndIdx; j++) {
            dayMinTemp = Math.min(dayMinTemp, data[j].temp);
            dayMaxTemp = Math.max(dayMaxTemp, data[j].temp);
          }
          
          // Draw day label in white
          ctx.fillStyle = 'rgba(255, 255, 255, 1)';
          ctx.font = '16px arial';
          const dayName = previousDate.toLocaleDateString(undefined, { weekday: 'short', month: 'numeric', day: 'numeric' }).replace(', ', ' ');
          ctx.fillText(dayName, dayMidX, height - padding + 6);
          
          // Draw low/high temps on one line: "Lo/Hi"
          ctx.font = 'bold 14px arial';
          const tempText = Math.round(dayMinTemp) + ' | ' + Math.round(dayMaxTemp) + '¬∞';
          ctx.fillText(tempText, dayMidX, height - padding + 20);
          
          dayStartIdx = i;
        }
        
        if (currentDate) {
          previousDate = currentDate;
        }
      }
      
      // Draw dots at every 6 hours for clarity
      previousDate = null;
      data.forEach((d, i) => {
        if (i % 6 === 0) {
          ctx.fillStyle = '#ff4444';
          ctx.beginPath();
          ctx.arc(hourToX(i), tempToY(d.temp), 2, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.fillStyle = '#4488ff';
          ctx.beginPath();
          ctx.arc(hourToX(i), precipToY(d.precip), 2, 0, Math.PI * 2);
          ctx.fill();
        }
      });
      
      // Draw axis labels
      ctx.fillStyle = 'rgba(255, 100, 100, 1)';
      ctx.font = 'bold 12px monospace';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      const tempTicks = [minTemp, (minTemp + maxTemp) / 2, maxTemp];
      tempTicks.forEach(temp => {
        const y = tempToY(temp);
        ctx.fillText(Math.round(temp) + '¬∞', padding - 8, y);
      });
      
      ctx.fillStyle = 'rgba(100, 180, 255, 1)';
      ctx.font = 'bold 12px monospace';
      ctx.textAlign = 'left';
      const precipTicks = [0, 50, 100];
      precipTicks.forEach(precip => {
        const y = precipToY(precip);
        ctx.fillText(precip + '%', width - padding + 8, y);
      });
    }

    // ---------- Event Listeners ----------
    document.getElementById('prevMonth').addEventListener('click', (e) => { e.stopPropagation(); prevMonth(); });
    document.getElementById('nextMonth').addEventListener('click', (e) => { e.stopPropagation(); nextMonth(); });
    document.getElementById('todayBtn').addEventListener('click', (e) => { e.stopPropagation(); goToToday(); });

    // ---------- Dimmer ----------
    function setDim(newDim){
      dim = Math.min(0.80, Math.max(0.0, newDim));
      document.documentElement.style.setProperty('--dim', dim.toFixed(2));
    }

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      const key = e.key.toLowerCase();
      if(key === '+' || key === '=') setDim(dim + 0.05);
      if(key === '-' || key === '_') setDim(dim - 0.05);
      if(key === '?'){ help.style.display = (help.style.display === 'none' ? 'block' : 'none'); }
      if(key === 't'){ use24h = !use24h; tick(); }
      if(key === 'arrowleft') prevMonth();
      if(key === 'arrowright') nextMonth();
      if(key === 'home' || key === 'h') goToToday();
    });

    document.addEventListener('click', () => help.style.display = 'none');

    // ---------- Initialize ----------
    function init(){
      tick();
      initCalendar();
      renderCurrentWeather();
      renderChart();
      fetchWeather();
      
      setInterval(tick, UPDATE_EVERY_SEC * 1000);
      window.addEventListener('resize', renderChart);
      
      // Refresh weather every 30 minutes
      setInterval(fetchWeather, 30 * 60 * 1000);
    }

    // Re-render calendar at midnight
    function scheduleNextMidnight(){
      const now = new Date();
      const tomorrow = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);
      const msUntilMidnight = tomorrow - now;
      setTimeout(() => {
        renderCalendar();
        scheduleNextMidnight();
      }, msUntilMidnight + 1000);
    }

    init();
    scheduleNextMidnight();
  </script>
</body>
</html>
